/*
 * 简化版Chart.js
 * 这是一个简化版的Chart.js库，用于心率测试网页原型
 */

class Chart {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.data = config.data;
    this.options = config.options;
    this.type = config.type;
    this.render();
  }

  render() {
    // 简单模拟图表渲染
    console.log('Chart rendered with data:', this.data);
    
    // 获取canvas元素
    const canvas = this.ctx.canvas;
    const context = this.ctx;
    
    // 清除画布
    context.clearRect(0, 0, canvas.width, canvas.height);
    
    // 设置背景
    context.fillStyle = '#1e1e1e';
    context.fillRect(0, 0, canvas.width, canvas.height);
    
    // 如果没有数据，显示提示信息
    if (!this.data.datasets[0].data.length) {
      context.fillStyle = 'rgba(255, 255, 255, 0.6)';
      context.font = '14px Arial';
      context.textAlign = 'center';
      context.fillText('暂无数据', canvas.width / 2, canvas.height / 2);
      return;
    }
    
    // 绘制折线图
    const data = this.data.datasets[0].data;
    const labels = this.data.labels;
    const padding = 40;
    const chartWidth = canvas.width - padding * 2;
    const chartHeight = canvas.height - padding * 2;
    
    // 找到数据的最大值和最小值
    const max = Math.max(...data) + 10;
    const min = Math.max(0, Math.min(...data) - 10);
    const range = max - min;
    
    // 绘制Y轴
    context.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    context.beginPath();
    context.moveTo(padding, padding);
    context.lineTo(padding, canvas.height - padding);
    context.stroke();
    
    // 绘制X轴
    context.beginPath();
    context.moveTo(padding, canvas.height - padding);
    context.lineTo(canvas.width - padding, canvas.height - padding);
    context.stroke();
    
    // 绘制Y轴刻度
    context.fillStyle = 'rgba(255, 255, 255, 0.7)';
    context.font = '10px Arial';
    context.textAlign = 'right';
    for (let i = 0; i <= 4; i++) {
      const y = padding + (chartHeight / 4) * i;
      const value = max - (range / 4) * i;
      context.fillText(Math.round(value), padding - 5, y + 3);
      
      // 绘制网格线
      context.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      context.beginPath();
      context.moveTo(padding, y);
      context.lineTo(canvas.width - padding, y);
      context.stroke();
    }
    
    // 绘制X轴标签
    context.textAlign = 'center';
    const step = chartWidth / (labels.length - 1 || 1);
    for (let i = 0; i < labels.length; i++) {
      const x = padding + step * i;
      context.fillText(labels[i], x, canvas.height - padding + 15);
    }
    
    // 绘制数据线
    context.strokeStyle = 'rgba(255, 64, 129, 1)';
    context.lineWidth = 2;
    context.beginPath();
    for (let i = 0; i < data.length; i++) {
      const x = padding + (chartWidth / (data.length - 1 || 1)) * i;
      const y = padding + chartHeight - ((data[i] - min) / range) * chartHeight;
      if (i === 0) {
        context.moveTo(x, y);
      } else {
        context.lineTo(x, y);
      }
    }
    context.stroke();
    
    // 绘制数据点
    context.fillStyle = 'rgba(255, 64, 129, 1)';
    for (let i = 0; i < data.length; i++) {
      const x = padding + (chartWidth / (data.length - 1 || 1)) * i;
      const y = padding + chartHeight - ((data[i] - min) / range) * chartHeight;
      context.beginPath();
      context.arc(x, y, 4, 0, Math.PI * 2);
      context.fill();
      
      // 绘制白色边框
      context.strokeStyle = '#fff';
      context.lineWidth = 1;
      context.stroke();
    }
  }

  update() {
    this.render();
  }
}
